import shutil
import os

import Writable
from FileCreator import FileCreator
from volatileApp.Application import Application


class ScriptWriter(FileCreator):
    '''
    Class used for creating bash script files.
    Implements the FileCreator
    '''

    # Header constant for the script
    # Contains routine for calling the installer script
    _header_installer = '#This script was generated by volatileBash\n' \
              'echo Do you want to run the Application Installer? [Y/N]\n' \
              'read input\n' \
              'if [[ $input =~ ^([yY][eE][sS]|[yY])$ ]]\n' \
              'then\n' \
              '\techo Installing...\n' \
              '\tbash ./installer.sh\n' \
              'else\n' \
              '\techo Skipping Installer\n' \
              'fi\n\n'

    _header_dumper = 'echo Do you want to do the Memory Acquisition with the supplied LiME module afterwards? [Y/N]\n' \
              'read input\n\n'

    _footer_dumper = 'if [[ $input =~ ^([yY][eE][sS]|[yY])$ ]]\n' \
              'then\n' \
              '\techo Dumping Memory...\n' \
              '\tbash ./dumper.sh\n' \
              'else\n' \
              '\techo Skipping Dumper\n' \
              'fi\n\n'


    def __init__(self, dirPath, addDumper=False):
        '''
        creates a new ScriptWriter object
        :param filePath: the path to the output file
        '''
        super(ScriptWriter, self).__init__(dirPath)
        self.writables = []
        self.addDumper = addDumper

    def add(self, writable):
        '''
        adds a new writable to the script.
        The writables will be executed in paralell (& concatinator)
        :param writable: the writable to be added
        :return: the ScriptWriter object for method chaining
        '''
        self.writables.append(writable)

        return self

    def andParalell(self, writable):
        '''
        adds a new writable to the script.
        The writables will be executed in strict sequence (&& concatinator)
        :param writable: the writable to be added
        :return: the ScriptWriter object for method chaining
        '''
        self.writables.append(Writable.ParalellAnd())
        self.writables.append(writable)

        return self

    def getFileContent(self):
        content = self._header_installer

        if self.addDumper:
            content += "echo\necho\n"
            content += self._header_dumper

        content += 'true'

        for writable in self.writables:
            content += ' & ' + str(writable)

        if self.addDumper:
            content += "\necho\necho\n"
            content += self._footer_dumper
        return content

    def _makeInstaller(self):
        '''
        internal function for creating an installer script.
        This function will create an installer.sh file in the same dir as specified upon object creation.
        The resulting script will install all the Applications added to the main script
        :return: the ScriptWriter object for method chaining
        '''
        # create the Installer file in the same directory
        self._createFile('installer.sh')

        installerPath = self.dirPath + 'installer.sh'
        # adds installer routine for each Application in writables
        f = open(installerPath, 'ab')
        f.write("sudo apt-get -y update\n")
        for writable in self.writables:
            if isinstance(writable, Application):
                f.write(writable.install() + '\n')
        f.close()

        return self

    def _makeScript(self):
        '''
        internal function for creating the main script.
        The resulting script will contain all the writables in this model
        :return: the ScriptWriter object for method chaining
        '''

        self._createFile('script.sh')

        f = open(self.dirPath + 'script.sh', 'ab')
        f.write(self.getFileContent())
        f.close()

        return self

    def _makeDumper(self):
        self._createFile('dumper.sh')

        dumperPath = self.dirPath + 'dumper.sh'
        f = open(dumperPath, 'ab')
        f.write("sudo insmod ./lime/lime.ko \"path=./memory.dmp format=lime\"\n")

        targetDir = self.dirPath + 'lime'
        if not os.path.exists(targetDir):
            shutil.copytree("./res/LiME", targetDir);

        return self

    def flush(self):
        self._makeScript()
        self._makeInstaller()
        if self.addDumper:
            self._makeDumper()
