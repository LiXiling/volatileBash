import os
import shutil

import Writable
from FileCreator import FileCreator
from volatileApp.Application import Application


class Scripter(FileCreator):
    FILENAME = 'main.sh'

    def __init__(self, dirPath, enableDumper=False):
        super(Scripter, self).__init__(dirPath)

        self.writables = []

        self.helperDirPath = 'scripts/'

        self.installScript = InstallScriptWriter(self.helperDirPath, self)
        self.setupScript = SetupScriptWriter(self.helperDirPath, self)

        self.enableDumper = enableDumper
        if enableDumper:
            self.dumpScript = LimeScriptWriter(self.helperDirPath, self)

    def add(self, writable):
        '''
        adds a new writable to the script.
        The writables will be executed in paralell (& concatinator)
        :param writable: the writable to be added
        :return: the ScriptWriter object for method chaining
        '''
        self.writables.append((Writable.ParalellAnd()))
        self.writables.append(writable)

        return self

    def andSequence(self, writable):
        '''
        adds a new writable to the script.
        The writables will be executed in strict sequence (&& concatinator)
        :param writable: the writable to be added
        :return: the ScriptWriter object for method chaining
        '''
        self.writables.append(Writable.SequentialAnd())
        self.writables.append(writable)

        return self

    def getFileContent(self):
        content = '#This script was automatically generated by volatileBash\n' \
                  '\n' \
                  'echo Do you want to run the Installer before the Setup Phase? [Y/N]\n' \
                  'read installInput\n' \
                  '\n'

        if self.enableDumper:
            content += 'echo Do you want to run the LiME Memory Acquisition Tool after the Setup Phase? [Y/N]\n' \
                       'read dumpInput\n' \
                       '\n'

        content += 'if [[ $installInput =~ ^([yY][eE][sS]|[yY])$ ]]\n' \
                   'then\n' \
                   '\t echo Executing Installer...\n' \
                   '\t bash {0}\n' \
                   'else\n' \
                   '\t echo Skipping Installer\n' \
                   'fi\n' \
                   '\n' \
                   'echo Executing Setup Script\n' \
                   'bash {1}\n'.format(
            self.installScript.getPath(),
            self.setupScript.getPath()
        )

        if self.enableDumper:
            content += '\n' \
                       'if [[ $dumpInput =~ ^([yY][eE][sS]|[yY])$ ]]\n' \
                       'then\n' \
                       '\t echo Executing Memory Dump...\n' \
                       '\t bash {0}\n' \
                       'else \n' \
                       '\t echo Skipping Memory Dump\n' \
                       'fi\n'.format(
                self.dumpScript.getPath()
            )

        return content

    def flush(self):
        self.installScript.flush()
        self.setupScript.flush()

        if self.enableDumper:
            self.dumpScript.flush()

        return super(Scripter, self).flush()


class HelpScript(FileCreator):
    FILENAME = None

    def __init__(self, relDirPath, scripter):
        super(HelpScript, self).__init__(scripter.dirPath + relDirPath)
        self.relDirPath = relDirPath
        self.scripter = scripter

    def getPath(self):
        print self.relDirPath
        return self.relDirPath + self.FILENAME

    def flush(self):
        return super(HelpScript, self).flush()


class InstallScriptWriter(HelpScript):
    FILENAME = 'installer.sh'

    def getFileContent(self):
        content = 'sudo apt-get -y update\n'

        for writable in self.scripter.writables:
            if isinstance(writable, Application):
                content += writable.install() + '\n'
        return content


class SetupScriptWriter(HelpScript):
    FILENAME = 'setup.sh'

    def getFileContent(self):
        content = 'true'

        for writable in self.scripter.writables:
            content += str(writable)

        return content


class LimeScriptWriter(HelpScript):
    FILENAME = 'dumper.sh'

    def _copyLime(self):
        targetDir = self.dirPath + '/lime'
        if not os.path.exists(targetDir):
            shutil.copytree("./res/LiME", targetDir);

    def getFileContent(self):
        return 'sudo insmod {0}lime/lime.ko \"path=./memory.dmp format=lime\"\n'.format(
            self.relDirPath
        )

    def flush(self):
        self._copyLime()
        return super(LimeScriptWriter, self).flush()
